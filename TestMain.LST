C51 COMPILER V9.01   TESTMAIN                                                              11/06/2018 23:49:15 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE TESTMAIN
OBJECT MODULE PLACED IN TestMain.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE TestMain.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          /*************  功能说明    **************
   2          
   3          双串口全双工中断方式收发通讯程序。
   4          
   5          通过PC向MCU发送数据, MCU收到后通过串口把收到的数据原样返回.
   6          
   7          ******************************************/
   8          #include "STC_NET.h"
*** WARNING C280 IN LINE 33 OF STC_NET.H: 'brt': unreferenced local variable
*** WARNING C280 IN LINE 118 OF STC_NET.H: 'mode': unreferenced local variable
*** WARNING C280 IN LINE 123 OF STC_NET.H: 'name': unreferenced local variable
*** WARNING C280 IN LINE 123 OF STC_NET.H: 'password': unreferenced local variable
   9          
  10          //========================================================================
  11          // 函数: void main(void)
  12          // 描述: 主函数。
  13          // 参数: none.
  14          // 返回: none.
  15          // 版本: VER1.0
  16          // 日期: 2014-11-28
  17          // 备注: 
  18          //========================================================================
  19          void main(void)
  20          {
  21   1          P0M1 = 0;   P0M0 = 0;   //设置为准双向口
  22   1          P1M1 = 0;   P1M0 = 0;   //设置为准双向口
  23   1          P2M1 = 0;   P2M0 = 0;   //设置为准双向口
  24   1          P3M1 = 0;   P3M0 = 0;   //设置为准双向口
  25   1          P4M1 = 0;   P4M0 = 0;   //设置为准双向口
  26   1          P5M1 = 0;   P5M0 = 0;   //设置为准双向口
  27   1          P6M1 = 0;   P6M0 = 0;   //设置为准双向口
  28   1          P7M1 = 0;   P7M0 = 0;   //设置为准双向口
  29   1      
  30   1          UART1_config();    // 选择波特率, 2: 使用Timer2做波特率, 其它值: 使用Timer1做波特率.
*** WARNING C209 IN LINE 30 OF TESTMAIN.C: '_UART1_config': too few actual parameters
  31   1          EA = 1; //允许总中断
  32   1          P16 = 1;
  33   1          P47 = 1;
  34   1          P46 = 1;
  35   1              // delay_ms(250);
  36   1              // delay_ms(250);
  37   1              // delay_ms(250);
  38   1              // delay_ms(250);
  39   1              // delay_ms(250);
  40   1              // delay_ms(250);
  41   1              // delay_ms(250);
  42   1              // delay_ms(250);
  43   1              // delay_ms(250);
  44   1              // delay_ms(250);
  45   1              // delay_ms(250);
  46   1              // delay_ms(250);
  47   1          // delay_ms(250);
  48   1              // delay_ms(250);
  49   1              // delay_ms(250);
  50   1              // delay_ms(250);
C51 COMPILER V9.01   TESTMAIN                                                              11/06/2018 23:49:15 PAGE 2   

  51   1              // delay_ms(250);
  52   1              // delay_ms(250);
  53   1              // delay_ms(250);
  54   1              // delay_ms(250);
  55   1              // delay_ms(250);
  56   1              // delay_ms(250);
  57   1              // delay_ms(250);
  58   1              // delay_ms(250);
  59   1          // PrintString1("AT\r\n");
  60   1          // P16 = 0;
  61   1              // delay_ms(250);
  62   1              // delay_ms(250);
  63   1          
  64   1              // delay_ms(250);
  65   1              // delay_ms(250);
  66   1          // PrintString1("AT+CWMODE=1\r\n");
  67   1          // P47=0;
  68   1              // delay_ms(250);
  69   1              // delay_ms(250);
  70   1              // delay_ms(250);
  71   1              // delay_ms(250);
  72   1              // delay_ms(250);
  73   1              // delay_ms(250);
  74   1          // PrintString1("AT+CWJAP=\"lxxx\",\"liuxiao123\"\r\n");
  75   1          // P46=0;
  76   1          while(1){
  77   2              delay_ms(250);
  78   2              delay_ms(250);
  79   2              delay_ms(250);
  80   2              delay_ms(250);
  81   2                      delay_ms(250);
  82   2              delay_ms(250);
  83   2              delay_ms(250);
  84   2              delay_ms(250);
  85   2                      delay_ms(250);
  86   2              delay_ms(250);
  87   2              delay_ms(250);
  88   2              delay_ms(250);
  89   2                      delay_ms(250);
  90   2              delay_ms(250);
  91   2              delay_ms(250);
  92   2              PrintString1(esp_at);
  93   2          }
  94   1          // while(!RX1_process){
  95   1          //     PrintString1("AT\r\n");  //SUART1发送握手连接指令，返回"OK"
  96   1          //     delay_ms(250);
  97   1          // }
  98   1          // P16 = 0;
  99   1          // while(!BuffCMP("OK")&&!BuffCMP("no change")){
 100   1          //     PrintString1("AT+CWMODE=1\r\n"); //设置ESP8266的工作模式1 Station，返回"OK"或者"no change"
 101   1          //     delay_ms(5000);
 102   1          // }
 103   1          // P47 = 0;
 104   1          // while(!BuffCMP("OK")){
 105   1          //     PrintString1("AT+CWJAP=\"ILX\",\"liuxiao123\"\r\n");
 106   1          //     delay_ms(7000);
 107   1          // }
 108   1          // P46 = 0;
 109   1          // while(1){
 110   1          //     P47 = 1;
 111   1          //     PrintString1("AT+CWMODE=1\r\n"); //设置ESP8266的工作模式1 Station，返回"OK"或者"no change"
 112   1          //     if(!RX1_process)   //收到数据
C51 COMPILER V9.01   TESTMAIN                                                              11/06/2018 23:49:15 PAGE 3   

 113   1          //     {
 114   1          //         if(RX1_Buffer[RX1_Cnt-1]=="OK" || RX1_Buffer[RX1_Cnt-1]=="no change"){
 115   1          //             P47 = 0;
 116   1          //             break;
 117   1          //         }
 118   1          //         RX1_process = 1;
 119   1          //     }
 120   1          //     // P47 = 0;
 121   1          // }
 122   1          // while(1){
 123   1          //     P46 = 0;
 124   1          //     PrintString1("AT+CWJAP=\"ILX\",\"liuxiao123\"\r\n");
 125   1          //     if(++TX1_Cnt >= UART1_BUF_LENGTH)   TX1_Cnt = 0;
 126   1          //     delay_ms(1000);
 127   1          //     if(!RX1_process)   //收到数据
 128   1          //     {
 129   1          //         if(RX1_Buffer[RX1_Cnt-1]=="OK" || RX1_Buffer[RX1_Cnt-1]=="no change"){
 130   1          //             P46 = 0;
 131   1          //             break;
 132   1          //         } 
 133   1          //         RX1_process = 1;
 134   1          //     }
 135   1          //     P46 = 1;
 136   1          // }
 137   1         
 138   1      
 139   1          // while (1)
 140   1          // {
 141   1          //     if((TX1_Cnt != RX1_Cnt) && (!B_TX1_Busy))   //收到数据, 发送空闲
 142   1          //     {
 143   1          //         SBUF = RX1_Buffer[TX1_Cnt];     //把收到的数据远样返回
 144   1          //         B_TX1_Busy = 1;
 145   1          //         if(++TX1_Cnt >= UART1_BUF_LENGTH)   TX1_Cnt = 0;
 146   1          //     }
 147   1          // }
 148   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    324    ----
   CONSTANT SIZE    =     54    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       8
   IDATA SIZE       =     32    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  5 WARNING(S),  0 ERROR(S)
